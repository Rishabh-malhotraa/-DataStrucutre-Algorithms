{
  "CP Starter Template": {
    "prefix": "cpcf",
    "body": [
      "/*",
      " ____  _     _           _     _       __  __       _ _           _",
      "|  _ \\(_)___| |__   __ _| |__ | |__   |  \\/  | __ _| | |__   ___ | |_ _ __ __ _",
      "| |_) | / __| '_ \\ / _` | '_ \\| '_ \\  | |\\/| |/ _` | | '_ \\ / _ \\| __| '__/ _` |",
      "|  _ <| \\__ \\ | | | (_| | |_) | | | | | |  | | (_| | | | | | (_) | |_| | | (_| |",
      "|_| \\_\\_|___/_| |_|\\__,_|_.__/|_| |_| |_|  |_|\\__,_|_|_| |_|\\___/ \\__|_|  \\__,_|",
      "",
      "*/",
      "",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "void solve()",
      "{",
      "  int n;",
      "  cin >> n;",
      "  vector<int> arr(n);",
      "  for (int i = 0; i < n; i++)",
      "    cin >> arr[i];",
      "",
      "  return;",
      "}",
      "",
      "int main()",
      "{",
      "  ios_base::sync_with_stdio(false);",
      "  cin.tie(NULL);",
      "#ifndef ONLINE_JUDGE",
      "  freopen(\"input.txt\", \"r\", stdin);",
      "  freopen(\"output.txt\", \"w\", stdout);",
      "#endif",
      "",
      "  int t;",
      "  cin >> t;",
      "  while (t--)",
      "  {",
      "    solve();",
      "  }",
      "  return 0;",
      "}"
    ],
    "description": "Competitve Programming starter template"
  },
  "input": {
    "prefix": "cpinp",
    "body": ["#ifndef ONLINE_JUDGE", "\tfreopen(\"input.txt\", \"r\", stdin);", "\tfreopen(\"output.txt\", \"w\", stdout);", "#endif\n\t"],
    "description": "Reading input from textfile "
  },
  "timer": {
    "prefix": "cptime",
    "body": [
      "#include <chrono>",
      "class Timer",
      "{",
      "public:",
      "  std::chrono::time_point<std::chrono::high_resolution_clock> start, end;",
      "  std::chrono::duration<float> duration;",
      "  Timer()",
      "  {",
      "    start = std::chrono::high_resolution_clock::now();",
      "  }",
      "  ~Timer()",
      "  {",
      "    end = std::chrono::high_resolution_clock::now();",
      "    duration = end - start;",
      "    float ms = duration.count() * 1000.0f;",
      "    cout << \" Code executed in \" << ms << \"ms \" << endl;",
      "  }",
      "};"
    ],
    "description": "Reading input from textfile "
  },
  "dpprint": {
    "prefix": "cpdp",
    "body": [
      "for (int i = 0; i < n; i++)",
      "{",
      "  for (int j = 0; j < n; j++)",
      "  {",
      "    cout << setw(3) << dp[i][j] << \" \";",
      "  }",
      "  cout << endl;",
      "}",
      ""
    ],
    "description": "Print the lookup dp matrix"
  },
  "vector 1-D": {
    "prefix": "cp1d",
    "body": ["vector<int> ${arr} (n, 0);"],
    "description": "Intialize a 1-Dimensional vector"
  },
  "Vector -2d": {
    "prefix": "cp2d",
    "body": ["vector<vector<int>> dp (n$1, vector<int>(n$2, 0));"],
    "description": "Initialise a 2 dimensional Vector"
  },
  "vector 3D": {
    "prefix": "cp3d",
    "body": ["vector<vector<vector<int>>> dp(n$1, vector<vector<int>>(n$2, vector<int>(n$3, 0)));"],
    "description": "3D Vector Initialization "
  },
  "2D loop": {
    "prefix": "cp2dfor",
    "body": ["for (int i = 0; i < n$1; i++)", "{", "    for (int j = 0; j < n$2; j++)", "    {", "    }", "}"],
    "description": "Loop 2-D"
  },
  "2D Gap loop": {
    "prefix": "cp2dgap",
    "body": [
      "for (int gap = 0; gap < n; gap++)",
      "{",
      "  for (int i = 0, j = gap; j < n; i++, j++)",
      "  {",
      "    if (gap == 0)",
      "    {",
      "    }",
      "    else if (gap == 1)",
      "    {",
      "    }",
      "    else",
      "    {",
      "      for (int k = i; k < j; k++)",
      "      {",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "description": "For loop snippet for looping though all subarrays of that matrix"
  },
  "New line": {
    "prefix": "cppnl",
    "body": ["cout << endl;"],
    "description": "Print a new line"
  },
  "Print True | False": {
    "prefix": "cpbool",
    "body": ["( ${func} (arr$1, k$2) ? \"TRUE\" : \"FALSE\")"],
    "description": "Print True or False"
  },
  "Linked List Struct": {
    "prefix": "cplist",
    "body": [
      "class ListNode\r",
      "{\r",
      "public:",
      "  int val;\r",
      "  ListNode *next;\r",
      "  ListNode() : val(0), next(nullptr) {}\r",
      "  ListNode(int x) : val(x), next(nullptr) {}\r",
      "  ListNode(int x, ListNode *next) : val(x), next(next) {}\r",
      "};"
    ],
    "description": "Linked List Template"
  },
  "Binary Tree Struct": {
    "prefix": "cptree",
    "body": [
      "class TreeNode\r",
      "{\r",
      "public:",
      "  int val;\r",
      "  TreeNode *left;\r",
      "  TreeNode *right;\r",
      "  TreeNode() : val(0), left(nullptr), right(nullptr) {}\r",
      "  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r",
      "  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r",
      "};"
    ],
    "description": " Definition for a binary tree node."
  },
  "Graph Struct": {
    "prefix": "cpgraph",
    "body": [
      "#include <bits/stdc++.h>\r",
      "using namespace std;\r",
      "\r",
      "class Graph\r",
      "{\r",
      "private:",
      "  vector<list<int>> adj;\r",
      "  int V;\r",
      "\r",
      "public:\r",
      "  Graph(int N)\r",
      "  {\r",
      "    V = N;\r",
      "    adj.resize(N, list<int>());\r",
      "  }\r",
      "  void addEdge(int u, int v)\r",
      "  {\r",
      "    adj[v].push_back(u);\r",
      "    adj[u].push_back(v);\r",
      "  }\r",
      "};\r",
      "\r",
      "int main()\r",
      "{\r",
      "  int n;\r",
      "  cin >> n;\r",
      "  return 0;\r",
      "}"
    ],
    "description": "Graph Template with adjacency list"
  },
  "1D Vector Input": {
    "prefix": "cp1dinp",
    "body": [
      "    int n, k;",
      "    cin >> n >> k;",
      "",
      "    vector<int> arr(n);",
      "    for (int i = 0; i < n; i++)",
      "        cin >> arr[i];",
      ""
    ],
    "description": "Snippet to input a 1D array "
  },
  "2D Vector input": {
    "prefix": "cp2dinp",
    "body": [
      "  int m, n;\r",
      "  cin >> m >> n;\r",
      "  vector<vector<int>> arr(m, vector<int>(m, 0));\r",
      "\r",
      "  for (int i = 0; i < m; i++)\r",
      "    for (int j = 0; j < n; j++)\r",
      "      cin >> arr[i][j];"
    ],
    "description": "Snippet to input a 2D array"
  },
  "Linked List Input": {
    "prefix": "cpllinp",
    "body": [
      "  int n, k, el;\r",
      "  cin >> n >> k;\r",
      "  ListNode *preHead = new ListNode(-1, nullptr), *curr = preHead, *temp;\r",
      "  for (int i = 0; i < n; i++)\r",
      "  {\r",
      "    cin >> el;\r",
      "    temp = new ListNode(el);\r",
      "    curr->next = temp;\r",
      "    curr = curr->next;\r",
      "  }\r",
      "\r",
      "  ListNode *head = new ListNode(0, reverseKGroup(preHead->next, k));\r",
      "\r",
      "  while (head = head->next)\r",
      "    cout << head->val << \" \";\r",
      ""
    ],
    "description": "Enter Linked List"
  },
  "LeetCode Contest": {
    "prefix": "cplc",
    "body": [
      "#include <bits/stdc++.h>\r",
      "using namespace std;\r",
      "\r$1",
      "\r",
      "void solve()\r",
      "{\r",
      "  int n;\r",
      "  cin >> n;\r",
      "  vector<int> arr(n);\r",
      "  for (int i = 0; i < n; i++)\r",
      "    cin >> arr[i];\r",
      "\r",
      "  Solution *sol = new Solution();\r",
      "\r",
      "  cout << sol->maxAlternatingSum();\r",
      "}\r",
      "\r",
      "int main()\r",
      "{\r",
      "#ifndef ONLINE_JUDGE\r",
      "  freopen(\"input.txt\", \"r\", stdin);\r",
      "  freopen(\"output.txt\", \"w\", stdout);\r",
      "#endif\r",
      "\r",
      "  int t;\r",
      "  cin >> t;\r",
      "  while (t--)\r",
      "  {\r",
      "    solve();\r",
      "  }\r",
      "  return 0;\r",
      "}"
    ],
    "description": "Leetcode Contest"
  },
  "Adjacency List Snippet": {
    "prefix": "cpadjlist",
    "body": [
      "  vector<list<pair<int, int>>> buildGraph(vector<vector<int>> edgeList, int n)\r",
      "  {\r",
      "    vector<list<pair<int, int>>> adjList(n);\r",
      "    for (vector<int> edges : edgeList)\r",
      "    {\r",
      "      int u = edges[0];\r",
      "      int v = edges[1];\r",
      "      int wt = edges[2];\r",
      "      adjList[u].push_back({v, wt});\r",
      "    }\r",
      "    return adjList;\r",
      "  }"
    ],
    "description": "Create Adjacency List from Edge List"
  },
  "name": {
    "prefix": "cpname",
    "body": [
      "\r",
      "//*  ____  _     _           _     _       __  __       _ _           _             \r",
      "//* |  _ \\(_)___| |__   __ _| |__ | |__   |  \\/  | __ _| | |__   ___ | |_ _ __ __ _ \r",
      "//* | |_) | / __| '_ \\ / _` | '_ \\| '_ \\  | |\\/| |/ _` | | '_ \\ / _ \\| __| '__/ _` |\r",
      "//* |  _ <| \\__ \\ | | | (_| | |_) | | | | | |  | | (_| | | | | | (_) | |_| | | (_| |\r",
      "//* |_| \\_\\_|___/_| |_|\\__,_|_.__/|_| |_| |_|  |_|\\__,_|_|_| |_|\\___/ \\__|_|  \\__,_|\r",
      "\r",
      ""
    ],
    "description": "ASCII ART Name"
  },
  "Header Imports": {
    "prefix": "cpheader",
    "body": [
      "/*",
      " ____  _     _           _     _       __  __       _ _           _\r",
      "|  _ \\(_)___| |__   __ _| |__ | |__   |  \\/  | __ _| | |__   ___ | |_ _ __ __ _\r",
      "| |_) | / __| '_ \\ / _` | '_ \\| '_ \\  | |\\/| |/ _` | | '_ \\ / _ \\| __| '__/ _` |\r",
      "|  _ <| \\__ \\ | | | (_| | |_) | | | | | |  | | (_| | | | | | (_) | |_| | | (_| |\r",
      "|_| \\_\\_|___/_| |_|\\__,_|_.__/|_| |_| |_|  |_|\\__,_|_|_| |_|\\___/ \\__|_|  \\__,_|\r",
      "\r",
      "*/\r",
      "\r",
      "#include <bits/stdc++.h>\r",
      "using namespace std;\r",
      "\r",
      ""
    ],
    "description": "Header File with ASCII Art"
  },
  "Disjoint Set": {
    "prefix": "cpdsu",
    "body": [
      "class DisjointSet\r",
      "{\r",
      "private:\r",
      "  vector<int> parent;\r",
      "  vector<int> rank;\r",
      "\r",
      "public:\r",
      "  DisjointSet(int N)\r",
      "  {\r",
      "    parent.assign(N, -1);\r",
      "    rank.assign(N, 1);\r",
      "  }\r",
      "\r",
      "  // Find the parent of the Disjoint Set\r",
      "  int find(int u)\r",
      "  {\r",
      "    if (parent[u] == -1)\r",
      "      return u;\r",
      "\r",
      "    else\r",
      "      return parent[u] = find(parent[u]);\r",
      "  }\r",
      "\r",
      "  // Merge Two Disjoint Sets\r",
      "  void Union(int u, int v)\r",
      "  {\r",
      "    u = find(u);\r",
      "    v = find(v);\r",
      "\r",
      "    if (u == v)\r",
      "      return;\r",
      "    else\r",
      "    {\r",
      "      if (rank[u] > rank[v])\r",
      "      {\r",
      "        parent[v] = u;\r",
      "        rank[u] += rank[v];\r",
      "      }\r",
      "      else\r",
      "      {\r",
      "        parent[u] = v;\r",
      "        rank[v] += rank[u];\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "\r",
      "  // Checks whether two elements are in the same set of not\r",
      "  bool check(int u, int v)\r",
      "  {\r",
      "    return (find(u) == find(v)) ? true : false;\r",
      "  }\r",
      "\r",
      "  // Count the numeber of Disjoint Sets\r",
      "  int getDisjointSets()\r",
      "  {\r",
      "    return count(parent.begin(), parent.end(), -1);\r",
      "  }\r",
      "\r",
      "  // Get the size of the Disjoint Set\r",
      "  int getRank(int u)\r",
      "  {\r",
      "    return rank[u];\r",
      "  }\r",
      "\r",
      "  // Get the Largest Disjoint Set\r",
      "  int getMaxRank()\r",
      "  {\r",
      "    return *max_element(rank.begin(), rank.end());\r",
      "  }\r",
      "};"
    ],
    "description": "Disjoint Set Starter Template"
  },
  "Direction Vector": {
    "prefix": "cpdir",
    "body": ["vector<vector<int>> dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};"],
    "description": "DIrection Vector For DFS Search"
  },
  "Boundry Conditions": {
    "prefix": "cpisValid",
    "body": ["int m, n;", "bool isValid(int i, int j)\r", "{\r", "  return (i >= 0 && i < m && j >= 0 && j < n);\r", "}"],
    "description": "Checking if co-ordinates are in the grid or not"
  },
  "Boundry Conditions Lamda": {
    "prefix": "cpisValidII",
    "body": ["auto isValid = [m, n](int x, int y)\r", "{\r", "  return (i >= 0 && i < m && j >= 0 && j < n);\r", "}"],
    "description": "Checking if co-ordinates are in the grid or not"
  },
  "Sieve of Eratosthenes": {
    "prefix": "cpseive",
    "body": [
      "set<int> getPrimes(int &n)\r",
      "{\r",
      "  set<int> primes;\r",
      "  vector<bool> visited(n + 1, true);\r",
      "  for (int i = 2; i <= n; i++)\r",
      "    if (visited[i] == true)\r",
      "      for (int j = i * i; j <= n; j += i)\r",
      "        visited[j] = false;\r",
      "\r",
      "  for (int idx = 2; idx <= n; idx++)\r",
      "    if (visited[idx] == true)\r",
      "      primes.insert(idx);\r",
      "\r",
      "  return primes;\r",
      "}"
    ],
    "description": "Get Prime Numbers from [0,n] in O(nlog(logn)) Time Complexity "
  },
  "Trie": {
    "prefix": "cptrie",
    "body": [
      "const int ALPHABET_SIZE = 26;",
      "",
      "class TrieNode",
      "{",
      "public:",
      "  vector<TrieNode *> children;",
      "  bool isTerminal;",
      "  TrieNode()",
      "  {",
      "    children.assign(ALPHABET_SIZE, NULL);",
      "    isTerminal = false;",
      "  }",
      "};",
      "",
      "class Trie",
      "{",
      "private:",
      "  TrieNode *root;",
      "",
      "public:",
      "  Trie(vector<string> words = {})",
      "  {",
      "    root = new TrieNode();",
      "",
      "    for (string word : words)",
      "      this->insert(word);",
      "  }",
      "  void insert(string key)",
      "  {",
      "    TrieNode *node = root;",
      "    for (char ch : key)",
      "    {",
      "      char index = ch - 'a';",
      "      if (node->children[index] == NULL)",
      "        node->children[index] = new TrieNode();",
      "",
      "      node = node->children[index];",
      "    }",
      "    node->isTerminal = true;",
      "  }",
      "",
      "  bool search(string key, bool searchPrefix = false)",
      "  {",
      "    TrieNode *node = root;",
      "",
      "    for (char ch : key)",
      "    {",
      "      int index = ch - 'a';",
      "      if (node->children[index] == NULL)",
      "        return false;",
      "",
      "      node = node->children[index];",
      "    }",
      "",
      "    return searchPrefix ? true : node->isTerminal;",
      "  }",
      "};"
    ],
    "description": "Implementation of Trie Data Structure"
  },
  "Grid Dimensions": {
    "prefix": "cpsize",
    "body": ["m = grid.size(), n = grid[0].size();"],
    "description": "Length of Rows and Columns of a grid"
  },
  "Rabin Karp": {
    "prefix": "cprabin",
    "body": [
      "class RabinKarp",
      "{",
      "private:",
      "  const int MOD = 1e9 + 7;",
      "  const int base = 229;",
      "  vector<long long> baseHash, textHash;",
      "  string text;",
      "",
      "  vector<long long> getHash(string s)",
      "  {",
      "    int n = s.size();",
      "    vector<long long> hash(n + 1, 0);",
      "",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "      int ch = s[i] - 'a' + 1;",
      "      hash[i + 1] = (hash[i] + ch * baseHash[i]) % MOD;",
      "    }",
      "    return hash;",
      "  }",
      "",
      "public:",
      "  RabinKarp(string text)",
      "  {",
      "    this->text = text;",
      "    int n = text.size();",
      "    baseHash.assign(n + 1, 1);",
      "    textHash.assign(n + 1, 0);",
      "",
      "    for (int i = 0; i < n; i++)",
      "      baseHash[i + 1] = (baseHash[i] * base) % MOD;",
      "",
      "    textHash = getHash(text);",
      "  }",
      "",
      "  // get the occurances of string position of pattern match",
      "  vector<int> occurances(string pattern)",
      "  {",
      "    vector<int> indices;",
      "",
      "    long long patternHash = getHash(pattern).back();",
      "    int n = text.size(), m = pattern.size();",
      "",
      "    for (int i = 0; i <= n - m; i++)",
      "    {",
      "      long long windowHash = (textHash[i + m] - textHash[i] + MOD) % MOD;",
      "",
      "      if (windowHash == (patternHash * baseHash[i]) % MOD)",
      "        indices.push_back(i);",
      "    }",
      "    return indices;",
      "  }",
      "};"
    ],
    "description": "Rabin Karp Algorithm for pattern matching"
  }
}
