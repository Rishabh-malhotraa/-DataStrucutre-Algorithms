{
  "CP Starter Template": {
    "prefix": "cpcf",
    "body": [
      "/*\r",
      " ____  _     _           _     _       __  __       _ _           _             \r",
      "|  _ \\(_)___| |__   __ _| |__ | |__   |  \\/  | __ _| | |__   ___ | |_ _ __ __ _ \r",
      "| |_) | / __| '_ \\ / _` | '_ \\| '_ \\  | |\\/| |/ _` | | '_ \\ / _ \\| __| '__/ _` |\r",
      "|  _ <| \\__ \\ | | | (_| | |_) | | | | | |  | | (_| | | | | | (_) | |_| | | (_| |\r",
      "|_| \\_\\_|___/_| |_|\\__,_|_.__/|_| |_| |_|  |_|\\__,_|_|_| |_|\\___/ \\__|_|  \\__,_|\r",
      "\r",
      "*/\r",
      "\r",
      "#include <bits/stdc++.h>\r",
      "using namespace std;\r",
      "\r",
      "void solve()\r",
      "{\r",
      "  int n;\r",
      "  cin >> n;\r",
      "  vector<int> arr(n);\r",
      "  for (int i = 0; i < n; i++)\r",
      "    cin >> arr[i];\r",
      "    $1\r",
      "  return;\r",
      "}\r",
      "\r",
      "int main()\r",
      "{\r",
      "  ios_base::sync_with_stdio(false);\r",
      "  cin.tie(NULL);\r",
      "#ifndef ONLINE_JUDGE\r",
      "  freopen(\"input.txt\", \"r\", stdin);\r",
      "  freopen(\"output.txt\", \"w\", stdout);\r",
      "#endif\r",
      "\r",
      "  int t;\r",
      "  cin >> t;\r",
      "  while (t--)\r",
      "  {\r",
      "    solve();\r",
      "  }\r",
      "  return 0;\r",
      "}"
    ],
    "description": "Competitve Programming starter template"
  },
  "input": {
    "prefix": "cpinp",
    "body": [
      "#ifndef ONLINE_JUDGE",
      "\tfreopen(\"input.txt\", \"r\", stdin);",
      "\tfreopen(\"output.txt\", \"w\", stdout);",
      "#endif\n\t"
    ],
    "description": "Reading input from textfile "
  },
  "timer": {
    "prefix": "cptime",
    "body": [
      "#include <chrono>",
      "class Timer",
      "{",
      "public:",
      "\tstd::chrono::time_point<std::chrono::high_resolution_clock> start, end;",
      "\tstd::chrono::duration<float> duration;",
      "\tTimer()\n\t{",
      "\t\tstart = std::chrono::high_resolution_clock::now();\n\t}",
      "\t~Timer()\n\t{",
      "\t\tend = std::chrono::high_resolution_clock::now();\n\t\tduration = end - start;",
      "\t\tfloat ms = duration.count() * 1000.0f;\n\t\tcout << \" Code executed in \" << ms << \"ms \" << endl;",
      "\t}",
      "};"
    ],
    "description": "Reading input from textfile "
  },
  "dpprint": {
    "prefix": "cpdp",
    "body": [
      "\tfor (int i = 0; i < n$1; i++)",
      "\t{",
      "\t\tfor (int j = 0; j < n$2; j++)",
      "\t\t{",
      "\t\t\tcout << setw(3) << dp[i][j] << \" \";",
      "\t\t}",
      "\t\tcout << endl;",
      "\t}",
      "$3"
    ],
    "description": "Print the lookup dp matrix"
  },
  "vector 1-D": {
    "prefix": "cp1d",
    "body": ["vector<int> ${arr} (n, 0);"],
    "description": "Intialize a 1-Dimensional vector"
  },
  "Vector -2d": {
    "prefix": "cp2d",
    "body": ["vector<vector<int>> dp (n$1, vector<int>(n$2, 0));"],
    "description": "Initialise a 2 dimensional Vector"
  },
  "vector 3D": {
    "prefix": "cp3d",
    "body": [
      "vector<vector<vector<int>>> dp(n$1, vector<vector<int>>(n$2, vector<int>(n$3, 0)));"
    ],
    "description": "3D Vector Initialization "
  },
  "2D loop": {
    "prefix": "cp2dfor",
    "body": [
      "for (int i = 0; i < n$1; i++)",
      "{",
      "    for (int j = 0; j < n$2; j++)",
      "    {",
      "    }",
      "}"
    ],
    "description": "Loop 2-D"
  },
  "2D Gap loop": {
    "prefix": "cp2dgap",
    "body": [
      "    for (int gap = 0; gap < n; gap++)",
      "    {",
      "        for (int i = 0, j = gap; j < n; i++, j++)",
      "        {",
      "            if (gap == 0)",
      "            {",
      "            }",
      "            else if (gap == 1)",
      "            {",
      "            }",
      "            else",
      "            {",
      "                for (int k = i; k < j; k++)",
      "                {",
      "                }",
      "            }",
      "        }",
      "    }"
    ],
    "description": "For loop snippet for looping though all subarrays of that matrix"
  },
  "New line": {
    "prefix": "cppnl",
    "body": ["cout << endl;"],
    "description": "Print a new line"
  },
  "Print True | False": {
    "prefix": "cpbool",
    "body": ["( ${func} (arr$1, k$2) ? \"TRUE\" : \"FALSE\")"],
    "description": "Print True or False"
  },
  "Linked List Struct": {
    "prefix": "cplist",
    "body": [
      "class ListNode\r",
      "{\r",
      "public:",
      "  int val;\r",
      "  ListNode *next;\r",
      "  ListNode() : val(0), next(nullptr) {}\r",
      "  ListNode(int x) : val(x), next(nullptr) {}\r",
      "  ListNode(int x, ListNode *next) : val(x), next(next) {}\r",
      "};"
    ],
    "description": "Linked List Template"
  },
  "Binary Tree Struct": {
    "prefix": "cptree",
    "body": [
      "class TreeNode\r",
      "{\r",
      "public:",
      "  int val;\r",
      "  TreeNode *left;\r",
      "  TreeNode *right;\r",
      "  TreeNode() : val(0), left(nullptr), right(nullptr) {}\r",
      "  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r",
      "  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r",
      "};"
    ],
    "description": " Definition for a binary tree node."
  },
  "Graph Struct": {
    "prefix": "cpgraph",
    "body": [
      "#include <bits/stdc++.h>\r",
      "using namespace std;\r",
      "\r",
      "class Graph\r",
      "{\r",
      "private:",
      "  vector<list<int>> adj;\r",
      "  int V;\r",
      "\r",
      "public:\r",
      "  Graph(int N)\r",
      "  {\r",
      "    V = N;\r",
      "    adj.resize(N, list<int>());\r",
      "  }\r",
      "  void addEdge(int u, int v)\r",
      "  {\r",
      "    adj[v].push_back(u);\r",
      "    adj[u].push_back(v);\r",
      "  }\r",
      "};\r",
      "\r",
      "int main()\r",
      "{\r",
      "  int n;\r",
      "  cin >> n;\r",
      "  return 0;\r",
      "}"
    ],
    "description": "Graph Template with adjacency list"
  },
  "1D Vector Input": {
    "prefix": "cp1dinp",
    "body": [
      "    int n, k;",
      "    cin >> n >> k;",
      "",
      "    vector<int> arr(n);",
      "    for (int i = 0; i < n; i++)",
      "        cin >> arr[i];",
      ""
    ],
    "description": "Snippet to input a 1D array "
  },
  "2D Vector input": {
    "prefix": "cp2dinp",
    "body": [
      "  int n, m;\r",
      "  cin >> n >> m;\r",
      "  vector<vector<int>> arr(n, vector<int>(m, 0));\r",
      "\r",
      "  for (int i = 0; i < n; i++)\r",
      "    for (int j = 0; j < m; j++)\r",
      "      cin >> arr[i][j];"
    ],
    "description": "Snippet to input a 2D array"
  },
  "Linked List Input": {
    "prefix": "cpllinp",
    "body": [
      "  int n, k, el;\r",
      "  cin >> n >> k;\r",
      "  ListNode *preHead = new ListNode(-1, nullptr), *curr = preHead, *temp;\r",
      "  for (int i = 0; i < n; i++)\r",
      "  {\r",
      "    cin >> el;\r",
      "    temp = new ListNode(el);\r",
      "    curr->next = temp;\r",
      "    curr = curr->next;\r",
      "  }\r",
      "\r",
      "  ListNode *head = new ListNode(0, reverseKGroup(preHead->next, k));\r",
      "\r",
      "  while (head = head->next)\r",
      "    cout << head->val << \" \";\r",
      ""
    ],
    "description": "Enter Linked List"
  },
  "LeetCode Contest": {
    "prefix": "cplc",
    "body": [
      "#include <bits/stdc++.h>\r",
      "using namespace std;\r",
      "\r$1",
      "\r",
      "void solve()\r",
      "{\r",
      "  int n;\r",
      "  cin >> n;\r",
      "  vector<int> arr(n);\r",
      "  for (int i = 0; i < n; i++)\r",
      "    cin >> arr[i];\r",
      "\r",
      "  Solution *sol = new Solution();\r",
      "\r",
      "  cout << sol->maxAlternatingSum();\r",
      "}\r",
      "\r",
      "int main()\r",
      "{\r",
      "#ifndef ONLINE_JUDGE\r",
      "  freopen(\"input.txt\", \"r\", stdin);\r",
      "  freopen(\"output.txt\", \"w\", stdout);\r",
      "#endif\r",
      "\r",
      "  int t;\r",
      "  cin >> t;\r",
      "  while (t--)\r",
      "  {\r",
      "    solve();\r",
      "  }\r",
      "  return 0;\r",
      "}"
    ],
    "description": "Leetcode Contest"
  },
  "Adjacency List Snippet": {
    "prefix": "cpadjlist",
    "body": [
      "  vector<list<pair<int, int>>> buildGraph(vector<vector<int>> edgeList, int n)\r",
      "  {\r",
      "    vector<list<pair<int, int>>> adjList(n);\r",
      "    for (vector<int> edges : edgeList)\r",
      "    {\r",
      "      int u = edges[0];\r",
      "      int v = edges[1];\r",
      "      int wt = edges[2];\r",
      "      adjList[u].push_back({v, wt});\r",
      "    }\r",
      "    return adjList;\r",
      "  }"
    ],
    "description": "Create Adjacency List from Edge List"
  },
  "name": {
    "prefix": "cpname",
    "body": [
      "\r",
      "//*  ____  _     _           _     _       __  __       _ _           _             \r",
      "//* |  _ \\(_)___| |__   __ _| |__ | |__   |  \\/  | __ _| | |__   ___ | |_ _ __ __ _ \r",
      "//* | |_) | / __| '_ \\ / _` | '_ \\| '_ \\  | |\\/| |/ _` | | '_ \\ / _ \\| __| '__/ _` |\r",
      "//* |  _ <| \\__ \\ | | | (_| | |_) | | | | | |  | | (_| | | | | | (_) | |_| | | (_| |\r",
      "//* |_| \\_\\_|___/_| |_|\\__,_|_.__/|_| |_| |_|  |_|\\__,_|_|_| |_|\\___/ \\__|_|  \\__,_|\r",
      "\r",
      ""
    ],
    "description": "ASCII ART Name"
  },
  "Header Imports": {
    "prefix": "cpheader",
    "body": [
      "/*",
      " ____  _     _           _     _       __  __       _ _           _\r",
      "|  _ \\(_)___| |__   __ _| |__ | |__   |  \\/  | __ _| | |__   ___ | |_ _ __ __ _\r",
      "| |_) | / __| '_ \\ / _` | '_ \\| '_ \\  | |\\/| |/ _` | | '_ \\ / _ \\| __| '__/ _` |\r",
      "|  _ <| \\__ \\ | | | (_| | |_) | | | | | |  | | (_| | | | | | (_) | |_| | | (_| |\r",
      "|_| \\_\\_|___/_| |_|\\__,_|_.__/|_| |_| |_|  |_|\\__,_|_|_| |_|\\___/ \\__|_|  \\__,_|\r",
      "\r",
      "*/\r",
      "\r",
      "#include <bits/stdc++.h>\r",
      "using namespace std;\r",
      "\r",
      ""
    ],
    "description": "Header File with ASCII Art"
  },
  "Disjoint Set": {
    "prefix": "cpdsu",
    "body": [
      "class DisjointSet\r",
      "{\r",
      "private:\r",
      "  vector<int> parent;\r",
      "  vector<int> rank;\r",
      "\r",
      "public:\r",
      "  DisjointSet(int N)\r",
      "  {\r",
      "    parent.resize(N, -1);\r",
      "    rank.resize(N, 1);\r",
      "  }\r",
      "\r",
      "  // Find the parent of the Disjoint Set\r",
      "  int find(int u)\r",
      "  {\r",
      "    if (parent[u] == -1)\r",
      "      return u;\r",
      "\r",
      "    else\r",
      "      return parent[u] = find(parent[u]);\r",
      "  }\r",
      "\r",
      "  // Merge Two Disjoint Sets\r",
      "  void Union(int u, int v)\r",
      "  {\r",
      "    u = find(u);\r",
      "    v = find(v);\r",
      "\r",
      "    if (u == v)\r",
      "      return;\r",
      "    else\r",
      "    {\r",
      "      if (rank[u] > rank[v])\r",
      "      {\r",
      "        parent[v] = u;\r",
      "        rank[u] += rank[v];\r",
      "      }\r",
      "      else\r",
      "      {\r",
      "        parent[u] = v;\r",
      "        rank[v] += rank[u];\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "\r",
      "  // Checks whether two elements are in the same set or not\r",
      "  bool isSameSet(int u, int v)\r",
      "  {\r",
      "    return (find(u) == find(v)) ? true : false;\r",
      "  }\r",
      "\r",
      "  // Count the numeber of Disjoint Sets\r",
      "  int getDisjointSets()\r",
      "  {\r",
      "    return count(parent.begin(), parent.end(), -1);\r",
      "  }\r",
      "\r",
      "  // Get the size of the Disjoint Set\r",
      "  int getRank(int u)\r",
      "  {\r",
      "    return rank[u];\r",
      "  }\r",
      "\r",
      "  // Get the Largest Disjoint Set\r",
      "  int getMaxRank()\r",
      "  {\r",
      "    return *max_element(rank.begin(), rank.end());\r",
      "  }\r",
      "};"
    ],
    "description": "Disjoint Set Starter Template"
  },
  "Direction Vector": {
    "prefix": "cpdir",
    "body": ["vector<vector<int>> dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};"],
    "description": "DIrection Vector For DFS Search"
  },
  "Boundry Conditions": {
    "prefix": "cpisValid",
    "body": [
      "bool isValid(int i, int j)\r",
      "  {\r",
      "    return (i >= 0 && i < m && j >= 0 && j < n);\r",
      "  }"
    ],
    "description": "Checking if co-ordinates are in the grid or not"
  },
  "Sieve of Eratosthenes": {
    "prefix": "cpseive",
    "body": [
      "set<int> getPrimes(int &n)\r",
      "{\r",
      "  set<int> primes;\r",
      "  vector<bool> visited(n, true);\r",
      "  for (int i = 2; i <= n; i++)\r",
      "    if (visited[i] == true)\r",
      "      for (int j = i * i; j < n; j += i)\r",
      "        visited[j] = false;\r",
      "\r",
      "  for (int idx = 2; idx <= n; idx++)\r",
      "    if (visited[idx] == true)\r",
      "      primes.insert(idx);\r",
      "\r",
      "  return primes;\r",
      "}"
    ],
    "description": "Get Prime Numbers from [0,n] in O(nlog(logn)) Time Complexity "
  }
}
